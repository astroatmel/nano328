/*  Version 1.2 of LED and HEATER

simple simple program that reads two dips and drives an output in pwm at 10hz 
AVR FUSES:
avrdude: safemode: lfuse reads as 62   [CLKDIV8 SKOUT SUT1 SUT0    CKSEL3  CKSEL2  CKSEL1  CKSEL0]    CKSEL=0x02 means Use internam 8Mhz Clock
avrdude: safemode: hfuse reads as D9   [RSTDISBL DWEN SPIEN WDTON  EESAVE BOOTSZ1 BOOTSZ0 BOOTRST]
avrdude: safemode: efuse reads as 7    (always 7)

Version 1.3: PD2 and PD6 reduces the PWM and ADC0 can be used with a POT
Version 1.2: PD2 and PD6 reduces the PWM
Version 1.1: Able to reach 0% PWM
Version 1.0: Initial release


The purpose is to drive the telescope heater in PWM

A328 Pins used:
PB0 10KHz  pwm out without pull up (push-pull), requires resistor to base of transistor (if not using mosfet)   <- active HIGH  max duty cycle set by MAX_PWM
PB1 10Hz   pwm out without pull up (push-pull), requires resistor to base of transistor (if not using mosfet)   <- active LOW
PB2 1Hz    pwm out without pull up (push-pull), requires resistor to base of transistor (if not using mosfet)   <- active LOW
            
Note, 
if PB0 drives a MOSFET transistor like FDU8878 and a 10Mh coil, the ouput can get very powerful
if using a NPN 2N5551, then the transistor saturates at 600ms and the output is less	

PC0 (ADC0)    can be a 0-5V signal from a POT 
              to activate this mode, short PD6-PD7 to ground, then the 328p will switch to analog mode and ignore the DIPS
              for this to work, set AVCC and AREF to 5V with a coil and capacitor
 
PD6 reduces   PWM (dip with pull-up : can be shorted)
PD2 reduces   PWM (dip with pull-up : can be shorted)
PD7 increaces PWM (dip with pull-up : can be shorted)

PB2 can be used to drive a heater and a led (indicator)
PB0 can drive a coil that will drive many leds in series ; 
    tested with 16 White LEDs (50V generated by the coil) 10mH
    10mH better than 1mH because the current doesn't saturate the coil at 10KHz
    it uses ~ 10mA at 50% PWM and outputs more light than the casquette at this level
    it uses ~ 23mA at 80% PWN
    Note, even at PWM=0%, the A328P uses 4mA 


   PROGMEM const char pololu[]={"\
A328p DIP:                                                        \012\015\
(PCINT14/RESET)      PC6   1 |    | 28  PC5 (ADC5/SCL/PCINT13)    \012\015\
(PCINT16/RXD)        PD0   2 |    | 27  PC4 (ADC4/SDA/PCINT12)    \012\015\
(PCINT17/TXD)        PD1   3 |    | 26  PC3 (ADC3/PCINT11)        \012\015\
(PCINT18/INT0)       PD2   4 |    | 25  PC2 (ADC2/PCINT10)        \012\015\
(PCINT19/OC2B/INT1)  PD3   5 |    | 24  PC1 (ADC1/PCINT9)         \012\015\
(PCINT20/XCK/T0)     PD4   6 |    | 23  PC0 (ADC0/PCINT8)         \012\015\
                     VCC   7 |    | 22  GND                       \012\015\
                     GND   8 |    | 21  AREF                      \012\015\
(PCINT6/XTAL1/TOSC1) PB6   9 |    | 20  AVCC                      \012\015\
(PCINT7/XTAL2/TOSC2) PB7  10 |    | 19  PB5 (SCK/PCINT5)          \012\015\
(PCINT21/OC0B/T1)    PD5  11 |    | 18  PB4 (MISO/PCINT4)         \012\015\
(PCINT22/OC0A/AIN0)  PD6  12 |    | 17  PB3 (MOSI/OC2A/PCINT3)    \012\015\
(PCINT23/AIN1)       PD7  13 |    | 16  PB2 (SS/OC1B/PCINT2)      \012\015\
(PCINT0/CLKO/ICP1)   PB0  14 |    | 15  PB1 (OC1A/PCINT1)         \012\015\
"};

*/

#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>

#define  RT_CPU_K_FRAME          1000
#define  PERIOD                  (RT_CPU_K_FRAME/10)

#define  TOP_INDICATOR            1024 // the PWMs are calculated using a base counter that goes from 0 to 1024
#define  MAX_PWM                  800  // 800 means that the max PWM is 80%

   void rt_init_disp(void)  // 1Khz
   {
   TIMSK1 |= 1 <<  TOIE1;    // timer1 interrupt when Overflow                    ///////////////// SP0C0
   // dont drive the pins TCCR1A  = 0xA3;           // FAST PWM, Clear OC1A/OC1B on counter match, SET on BOTTOM
   //TCCR1A  = 0x23;         // FAST PWM, Clear OC1B on counter match, SET on BOTTOM
   TCCR1A  = 0x33;           // FAST PWM, Set OC1B on counter match, CLEAR on BOTTOM
   TCCR1B  = 0x19;           // Clock divider set to 1 , FAST PWM, TOP = OCR1A
   OCR1A   = PERIOD;         // Clock divider set to 1, so RT_CPU_K_FRAME/1 is CLK / 1000 /1 thus, every 1000 there will be an interrupt : 1Khz
   }

volatile unsigned short indicator=250; 
volatile unsigned short timer1000Hz=0;
volatile unsigned short timer10Hz=0;
volatile unsigned short timer1Hz=0;
volatile unsigned short indicator_x_10=0;

ISR(TIMER1_OVF_vect)    // my SP0C0 @ 10 KHz
{
timer1000Hz++;
timer10Hz++;
timer1Hz++;
}

////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
unsigned char mode_count=10;
unsigned char mode=0;

int main(void)
{
long  temp;

//CLKPR =  0x80;  // 1Mhz clock div by 4   // I crashed a A328p using these
//CLKPR =  0x00;  // 1Mhz clock div by 4   // I crashed a A328p using these

PRR   =  0xF7;  // Enable Only TIMER 1

rt_init_disp();


DDRB  =  0x07;  // PB0 PWM out 1     Hz   
                // PB1 PWM out 10    Hz
                // PB2 PWM out 10000 Hz
PORTB =  0x00;  // No Pull up  on PORT B

DDRD  =  0x20;  // PD6/PD7 UP/DOWN DIP (Pullup)
PORTD =  0xC4;  // Pull up  on PD2 PD6 PD7


sei();         //enable global interrupts

volatile unsigned char  Joystick;

while(1) 
   {
   if ( indicator < MAX_PWM )  // 900/1000 is 90% max PWM
      {
      temp = (long) indicator * (long)PERIOD;
      OCR1B = (short)(PERIOD - (temp>>10));
      }
      
   if ( timer10Hz >= 1000 )        timer10Hz=0; // 10Hz loop
   if ( timer10Hz < indicator)     PORTB &=  0x01; 
   else                            PORTB |= ~0x01; 

   indicator_x_10 = 10*indicator;
   if ( timer1Hz >= 10000 )        timer1Hz=0; // 1Hz loop
   if ( timer1Hz < indicator_x_10) PORTB &=  0x02; 
   else                            PORTB |= ~0x02; 

   // initial startup, check for DIPs if both are down, then we are in analog mode  ( mode==0)
   if ( timer10Hz== 0&& mode_count>0 && mode==0 ) mode_count--;
   if ( mode_count ) // initial check..
      {
      if ( ((PIND & 0xC0) == 0) ) 
         {
         mode++; // both are down..so analog mode...
         PRR    = 0xF6;  // Enable Only TIMER 1 and ADC
         DIDR0  = 1;     // Disable digital input on ADC0
         ADMUX  = 0x21;
         ADCSRA = 0xC0;       // Start a conversion
         }
      }

   if ( mode == 0 ) //digital mode 
      {
      // Process buttons
         if ( timer1000Hz > 50 )
         {
         timer1000Hz = 0;
         if ( ((PIND & 0x80) == 0) && (indicator<TOP_INDICATOR))  indicator++;
         if ( ((PIND & 0x40) == 0) && (indicator>0   ))  indicator--;
         if ( ((PIND & 0x04) == 0) && (indicator>0   ))  indicator--;
         }
      }
   else
      {
      // process analog input
      if ( (ADCSRA & 0x40) == 0 ) // last conversion complete
         {
         Joystick = ADCH;
         indicator = Joystick<<2;
         ADMUX=0x20 | 0x40;
         ADCSRA = 0xC0;       // Start a conversion
         }
      }

   }

return 0;
}











