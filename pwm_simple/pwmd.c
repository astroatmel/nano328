/*  PWM LED driver and pwm HEATER

simple simple program that reads two dips and drives an output in pwm at 1Hz, 10Hz and 1KHz

AVR FUSES:
avrdude: safemode: lfuse reads as 62   [CLKDIV8 SKOUT SUT1 SUT0    CKSEL3  CKSEL2  CKSEL1  CKSEL0]    CKSEL=0x02 means Use internam 8Mhz Clock
avrdude: safemode: hfuse reads as D9   [RSTDISBL DWEN SPIEN WDTON  EESAVE BOOTSZ1 BOOTSZ0 BOOTRST]
avrdude: safemode: efuse reads as 7    (always 7)

Version 1.4: Switched back to SP0 at 1KHz for better precision 
             added internal temperature sensor which forces me to use internal 1.1v voltage reference
                so  aVcc has resistor + capacitor to bring stable 5v aVcc
                and aREF just has a capacitor to ground (though I see less noise without the capacitor to ground)
                this means that the Joystick must use the 1.1v Supply from aREF
             added RS232 debug output (connect strait to USB-TTY or pololu programmer, no need for inverter)

Version 1.3: PD2 and PD6 reduces the PWM and ADC0 can be used with a POT
Version 1.2: PD2 and PD6 reduces the PWM
Version 1.1: Able to reach 0% PWM
Version 1.0: Initial release


The purpose is to drive the telescope heater in PWM

A328 Pins used:
PB2 10KHz  pwm out without pull up (push-pull), requires resistor to base of transistor (if not using mosfet)   <- active HIGH  max duty cycle set by MAX_PWM
PB1 10Hz   pwm out without pull up (push-pull), requires resistor to base of transistor (if not using mosfet)   <- active LOW
PB0 1Hz    pwm out without pull up (push-pull), requires resistor to base of transistor (if not using mosfet)   <- active LOW
            
Note, 
if PB0 drives a MOSFET transistor like FDU8878 and a 10Mh coil, the ouput can get very powerful
if using a NPN 2N5551, then the transistor saturates at 600ms and the output is less	

PC0 (ADC0)    can be a 0-5V signal from a POT 
              to activate this mode, short PD6-PD7 to ground, then the 328p will switch to analog mode and ignore the DIPS
              for this to work, set AVCC and AREF to 5V with a coil and capacitor
 
PD6 reduces   PWM (dip with pull-up : can be shorted)
PD7 increaces PWM (dip with pull-up : can be shorted)

PB2 can be used to drive a heater and a led (indicator)
PB0 can drive a coil that will drive many leds in series ; 
    tested with 16 White LEDs (50V generated by the coil) 10mH
    10mH better than 1mH because the current doesn't saturate the coil at 10KHz
    it uses ~ 10mA at 50% PWM and outputs more light than the casquette at this level
    it uses ~ 23mA at 80% PWN
    Note, even at PWM=0%, the A328P uses 4mA 


   PROGMEM const char pololu[]={"\
A328p DIP:                                                        \012\015\
(PCINT14/RESET)      PC6   1 |    | 28  PC5 (ADC5/SCL/PCINT13)    \012\015\
(PCINT16/RXD)        PD0   2 |    | 27  PC4 (ADC4/SDA/PCINT12)    \012\015\
(PCINT17/TXD)        PD1   3 |    | 26  PC3 (ADC3/PCINT11)        \012\015\
(PCINT18/INT0)       PD2   4 |    | 25  PC2 (ADC2/PCINT10)        \012\015\
(PCINT19/OC2B/INT1)  PD3   5 |    | 24  PC1 (ADC1/PCINT9)         \012\015\
(PCINT20/XCK/T0)     PD4   6 |    | 23  PC0 (ADC0/PCINT8)         \012\015\
                     VCC   7 |    | 22  GND                       \012\015\
                     GND   8 |    | 21  AREF                      \012\015\
(PCINT6/XTAL1/TOSC1) PB6   9 |    | 20  AVCC                      \012\015\
(PCINT7/XTAL2/TOSC2) PB7  10 |    | 19  PB5 (SCK/PCINT5)          \012\015\
(PCINT21/OC0B/T1)    PD5  11 |    | 18  PB4 (MISO/PCINT4)         \012\015\
(PCINT22/OC0A/AIN0)  PD6  12 |    | 17  PB3 (MOSI/OC2A/PCINT3)    \012\015\
(PCINT23/AIN1)       PD7  13 |    | 16  PB2 (SS/OC1B/PCINT2)      \012\015\
(PCINT0/CLKO/ICP1)   PB0  14 |    | 15  PB1 (OC1A/PCINT1)         \012\015\
"};

*/

#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>

#define  RT_CPU_K_FRAME          1000
#define  PERIOD                  (RT_CPU_K_FRAME)

#define  TOP_INDICATOR            1000 // the PWMs are calculated using a base counter that goes from 0 to 999
#define  MAX_PWM                  800  // 800 means that the max PWM is 80%

void pc(char ccc)
{
while((UCSR0A & (1 <<UDRE0)) == 0);  // data register is empty...
UDR0 = ccc;
while((UCSR0A & (1 <<UDRE0)) == 0);  // data register is empty...
}

void ps(char *ssz)   // super simple blocking print string
{
while ( *ssz ) pc(*ssz++);
}

void pgm_ps(const char *ssz)   // super simple blocking print string
{
char tc = pgm_read_byte(ssz++);
while ( tc )
   {
   pc(tc);
   tc = pgm_read_byte(ssz++);
   }
}

void px(char *buf,char val)
{
unsigned short v0,v1;
v0 = (val>>4)&0xF;
v1 =  val    &0xF;

if ( v0 >=0  && v0<=9  ) buf[0] = '0' + v0;
else                     buf[0] = 'A' + v0 - 10;
if ( v1 >=0  && v1<=9  ) buf[1] = '0' + v1;
else                     buf[1] = 'A' + v1 - 10;
}

void p08x(char *bof,uint32_t value)
{
unsigned char *p_it = (unsigned char*) &value;
p_it = (unsigned char*) &value;
px(&bof[6],*p_it++);
px(&bof[4],*p_it++);
px(&bof[2],*p_it++);
px(&bof[0],*p_it++);
bof[8]=0;
}

void p04x(char *bof,uint16_t value)
{
unsigned char *p_it = (unsigned char*) &value;
p_it = (unsigned char*) &value;
px(&bof[2],*p_it++);
px(&bof[0],*p_it++);
bof[4]=0;
}

void p02x(char *bof,uint8_t value)
{
unsigned char *p_it = (unsigned char*) &value;
p_it = (unsigned char*) &value;
px(&bof[0],*p_it++);
bof[2]=0;
}



void init_rs232(long baud)
{
// using 8*baud with double clock speed to get a smaller error, see Examples of UBRRn Settings for Commonly Used Oscillator Frequencies in a328p pdf
unsigned long temp = RT_CPU_K_FRAME*1000UL/(8*baud)-1;  // set uart baud rate register 

UCSR0A = 0x02;  // double clock speed
UBRR0H = (temp >> 8);
UBRR0L = (temp & 0xFF);

UCSR0B=  1 << TXEN0 ;  // enable TX
//UCSR0B= (1 <<RXEN0 | 1 << TXEN0 );  // enable RX and TX
//UCSR0B|= (1 <<RXCIE0);              // enable receive complete interrupt
//UCSR0B|= (1 <<TXCIE0);              // enable transmit complete interrupt
UCSR0C = 0x06;             // 8 bits, no parity, 1 stop
}

void rt_init_disp(void)  // 1Khz
{
TIMSK1 |= 1 <<  TOIE1;    // timer1 interrupt when Overflow                    ///////////////// SP0C0
// dont drive the pins TCCR1A  = 0xA3;           // FAST PWM, Clear OC1A/OC1B on counter match, SET on BOTTOM
//TCCR1A  = 0x23;         // FAST PWM, Clear OC1B on counter match, SET on BOTTOM
TCCR1A  = 0x33;           // FAST PWM, Set OC1B on counter match, CLEAR on BOTTOM
TCCR1B  = 0x19;           // Clock divider set to 1 , FAST PWM, TOP = OCR1A
OCR1A   = PERIOD;         // Clock divider set to 1, so RT_CPU_K_FRAME/10 is CLK / 1000 /1 thus, every 1000 there will be an interrupt : 1Khz
}

volatile uint16_t indicator=250; 
volatile uint16_t indicator10=25;

volatile uint8_t  timer100Hz=0;
volatile uint16_t timer10Hz=0;
volatile uint16_t timer1Hz=0;

volatile uint8_t  mode_count=10;
volatile uint8_t  mode=0;

volatile uint16_t Temperature=0;
volatile uint16_t Joystick=0;
          uint8_t admux_tab[]={0xC8   // ADC8 ; Temperature sensor        0xC0  is for 1.1v internal reference
                              ,0xC0   // ADC0 ; Joystick                  0x20 is for left adjust    0x40 is for aVcc reference
                              }; // contains the chanel and the voltage reference for each test channel


ISR(TIMER1_OVF_vect)    // my SP0C0 @ 1 KHz
{
static uint8_t CHAN=0;
timer100Hz++;
timer10Hz++;
timer1Hz++;

if ( timer100Hz >= 10 )         timer100Hz=0; // 100Hz loop

if ( timer10Hz >= 100 )         timer10Hz=0;  // PB1 10Hz loop
if ( timer10Hz < indicator10)   PORTB &= ~0x02; 
else                            PORTB |=  0x02; 

if ( timer1Hz >= 1000 )         timer1Hz=0;   // PB0 1Hz loop
if ( timer1Hz < indicator)      PORTB &= ~0x01; 
else                            PORTB |=  0x01; 

if ( mode_count>0 && timer10Hz==0 ) mode_count--;

if ( indicator < MAX_PWM ) OCR1B = indicator; // 900/1000 is 90% max PWM

if ( mode == 0 && timer100Hz == 0)  //digital mode
   {
   // Process buttons
   if ( ((PIND & 0x80) == 0) && (indicator<TOP_INDICATOR))  indicator+=2;
   if ( ((PIND & 0x40) == 0) && (indicator>0   ))           indicator-=2;
   }
else  // process analog input 
   {
   if ( (ADCSRA & 0x40) == 0 ) // last conversion complete
      {
      if ( (admux_tab[CHAN] & 0x0F)  == 8 )  
         {
         Temperature  = ADCL;
         uint16_t tmp = ADCH;
         Temperature += tmp<<8;
         }
      if ( (admux_tab[CHAN] & 0x0F)  == 0 )  
         {
         uint32_t adcl  = ADCL;
         uint32_t adch  = ADCH;
         Joystick       =   (adch<<8)+adcl;              // original 0-1023
         }
   
      CHAN++;
      if (CHAN>=sizeof(admux_tab)) CHAN=0;
      ADMUX=admux_tab[CHAN]; 
      ADCSRA = 0xC0;       // Start a conversion
      } 
   }
}



////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
////////////////////////////////////////// MAIN ///////////////////////////////////////////////////

int main(void)
{
//CLKPR =  0x80;  // 1Mhz clock div by 4   // I crashed a A328p using these
//CLKPR =  0x00;  // 1Mhz clock div by 4   // I crashed a A328p using these

PRR   =  ~0x08;  // Enable Only TIMER 1 
PRR  &=  ~0x02;  // Enable RS232

rt_init_disp();
init_rs232(9600);

DDRB  =  0x07;  // PB0 PWM out 1     Hz   
                // PB1 PWM out 10    Hz
                // PB2 PWM out 10000 Hz
PORTB =  0x00;  // No Pull up  on PORT B

DDRD  =  0x22;  // PD6/PD7 UP/DOWN DIP (Pullup)   PD1 output for RS232
PORTD =  0xC0;  // Pull up  on PD6 PD7


sei();         //enable global interrupts

ps("\033[2JPWM LED driver and pwm HEATER   Version 1.4 \015\012");


while(1) 
   {
   // initial startup, check for DIPs if both are down, then we are in analog mode  ( mode==0)
   if ( mode_count ) // initial check..
      {
      if ( ((PIND & 0xC0) == 0) ) 
         {
         mode   = 1;      // both are down..so analog mode...
         PRR   &= ~0x01;  // Enable ADC
         DIDR0  = 1;      // Disable digital input on ADC0
         }
      }

   if ( mode == 0 ) //digital mode 
      {
      pc('D');
      }
   else
      {
      uint32_t tmp = Joystick;
      tmp = (tmp*1000)/1024;  // converted 0-999
      indicator      = tmp;
      indicator10    = indicator/10;                        // convert 0-99

      char BUF[10];
      ps("Temprature:0x"); p04x(BUF,Temperature); ps(BUF);
      if ( sizeof(admux_tab) > 1 ) { ps("   ADC0:0x"); p04x(BUF,Joystick); ps(BUF); }
//    { ps("   mode:0x"); p02x(BUF,mode); ps(BUF); }
      ps("   \015\012");
      }

   }

return 0;
}











