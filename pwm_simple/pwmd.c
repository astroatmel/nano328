/*  Version 1.1 of LED and HEATER

simple simple program that reads two dips and drives an output in pwm at 10hz 
AVR FUSES:
avrdude: safemode: lfuse reads as 62   [CLKDIV8 SKOUT SUT1 SUT0    CKSEL3  CKSEL2  CKSEL1  CKSEL0]    CKSEL=0x02 means Use internam 8Mhz Clock
avrdude: safemode: hfuse reads as D9   [RSTDISBL DWEN SPIEN WDTON  EESAVE BOOTSZ1 BOOTSZ0 BOOTRST]
avrdude: safemode: efuse reads as 7    (always 7)





The purpose is to drive the telescope heater in PWM

A328 Pins used:
PB0 10Hz   pwm out without pull up, requires resistor to base of transistor (if not using mosfet)
PB2 10KHz  pwm out without pull up, requires resistor to base of transistor (if not using mosfet)
PD6 reduces   PWM (dip with pull-up : can be shorted)
PD7 increaces PWM (dip with pull-up : can be shorted)

PB0 can be used to drive a heater and a led (indicator)
PB2 can drive a coil that will drive many leds in series ; 
    tested with 16 White LEDs (50V generated by the coil) 10mH
    10mH better than 1mH because the current doesn't saturate the coil at 10KHz
    it uses ~ 10mA at 50% PWM and outputs more light than the casquette at this level
    it uses ~ 23mA at 80% PWN
    Note, even at PWM=0%, the A328P uses 4mA 


   PROGMEM const char pololu[]={"\
A328p DIP:                                                        \012\015\
(PCINT14/RESET)      PC6   1 |    | 28  PC5 (ADC5/SCL/PCINT13)    \012\015\
(PCINT16/RXD)        PD0   2 |    | 27  PC4 (ADC4/SDA/PCINT12)    \012\015\
(PCINT17/TXD)        PD1   3 |    | 26  PC3 (ADC3/PCINT11)        \012\015\
(PCINT18/INT0)       PD2   4 |    | 25  PC2 (ADC2/PCINT10)        \012\015\
(PCINT19/OC2B/INT1)  PD3   5 |    | 24  PC1 (ADC1/PCINT9)         \012\015\
(PCINT20/XCK/T0)     PD4   6 |    | 23  PC0 (ADC0/PCINT8)         \012\015\
                     VCC   7 |    | 22  GND                       \012\015\
                     GND   8 |    | 21  AREF                      \012\015\
(PCINT6/XTAL1/TOSC1) PB6   9 |    | 20  AVCC                      \012\015\
(PCINT7/XTAL2/TOSC2) PB7  10 |    | 19  PB5 (SCK/PCINT5)          \012\015\
(PCINT21/OC0B/T1)    PD5  11 |    | 18  PB4 (MISO/PCINT4)         \012\015\
(PCINT22/OC0A/AIN0)  PD6  12 |    | 17  PB3 (MOSI/OC2A/PCINT3)    \012\015\
(PCINT23/AIN1)       PD7  13 |    | 16  PB2 (SS/OC1B/PCINT2)      \012\015\
(PCINT0/CLKO/ICP1)   PB0  14 |    | 15  PB1 (OC1A/PCINT1)         \012\015\
"};

*/

#include <avr/pgmspace.h>
#include <avr/io.h>
#include <avr/interrupt.h>

#define  RT_CPU_K_FRAME          1000
#define  PERIOD                  (RT_CPU_K_FRAME/10)

   void rt_init_disp(void)  // 1Khz
   {
   TIMSK1 |= 1 <<  TOIE1;    // timer1 interrupt when Overflow                    ///////////////// SP0C0
   // dont drive the pins TCCR1A  = 0xA3;           // FAST PWM, Clear OC1A/OC1B on counter match, SET on BOTTOM
   //TCCR1A  = 0x23;           // FAST PWM, Clear OC1B on counter match, SET on BOTTOM
   TCCR1A  = 0x33;           // FAST PWM, Set OC1B on counter match, CLEAR on BOTTOM
   TCCR1B  = 0x19;           // Clock divider set to 1 , FAST PWM, TOP = OCR1A
   OCR1A   = PERIOD;                 // Clock divider set to 1, so RT_CPU_K_FRAME/1 is CLK / 1000 /1 thus, every 1000 there will be an interrupt : 1Khz
   OCR1B   = PERIOD;                // By default, set the PWM to 25%

   OCR0A  =   10;  
   }

volatile unsigned short indicator=250; 
volatile unsigned short timer10KHz=0;
volatile unsigned short timer10Hz=0;

ISR(TIMER1_OVF_vect)    // my SP0C0 @ 10 KHz
{
timer10KHz++;
if ( timer10KHz >= 1000 ) // 10Hz loop
   {
   timer10KHz=0;
   }
if ( (timer10KHz & 0x0F) == 0 )
   {
   if ( ((PIND & 0x80) == 0) && (indicator<1000))  indicator++;
   if ( ((PIND & 0x40) == 0) && (indicator>0   ))  indicator--;
   }

if ( timer10KHz < indicator) PORTB |=  0x01; 
else                         PORTB &= ~0x01; 
}

////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
////////////////////////////////////////// MAIN ///////////////////////////////////////////////////
int main(void)
{
long  temp;

//CLKPR =  0x80;  // 1Mhz clock div by 4   // I crashed a A328p using these
//CLKPR =  0x00;  // 1Mhz clock div by 4   // I crashed a A328p using these
PRR   =  0xF7;  // Enable Only TIMER 1

rt_init_disp();


DDRB  |=  0x05;  // PB0 PWM out 1Hz   PB1 PWM 1KHz
DDRD  &= ~0xC0;  // PD6/PD7 UP/DOWN DIP (Pullup)
DDRD  |=  0x20;  // PD6/PD7 UP/DOWN DIP (Pullup)
PORTD |=  0xC0;  // Pull up


sei();         //enable global interrupts

while(1) 
   {
   temp = (long) indicator * (long)PERIOD;
   if ( indicator<800 ) OCR1B = 10 + PERIOD - (temp / 1000);

   //static char toggle=0;
   //if ( toggle ) {PORTB |=  0x01; toggle=0;} 
   //else          {PORTB &= ~0x01; toggle=1;} 
   }

return 0;
}











